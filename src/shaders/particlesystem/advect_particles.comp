#version 430 core

#ifndef GROUP_SIZE
#define GROUP_SIZE 256
#endif

layout (local_size_x = GROUP_SIZE) in;

struct Particle {
    vec4 position;      // xyz: position, w: age
    vec4 velocity;      // xyz: velocity, w: lifetime
    vec4 trail_pos[8];  // Trail positions for rendering
};

layout (std430, binding = 0) buffer particle_buffer {
    Particle particles[];
};

layout (std140, binding = 0) uniform advect_params {
    uvec3 volume_dim;       // Volume dimensions
    uint  num_particles;    // Number of particles
    vec3  volume_min;       // Volume AABB min
    float dt;               // Time step
    vec3  volume_max;       // Volume AABB max
    float scalar_min;       // Scalar threshold min for reseeding
    float scalar_max;       // Scalar threshold max for reseeding
    float min_lifetime;     // Minimum particle lifetime for reseeding
    float max_lifetime;     // Maximum particle lifetime for reseeding
    uint  random_seed;      // Random seed for reseeding
};

layout (binding = 0) uniform sampler3D volume_texture;

// Random number generator (PCG)
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float random_float(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) / 4294967296.0;
}

// Sample vector field at given position
vec3 sample_vector_field(vec3 pos) {
    // Convert world position to texture coordinates [0, 1]
    vec3 tex_coord = (pos - volume_min) / (volume_max - volume_min);
    
    // Clamp to valid range
    tex_coord = clamp(tex_coord, vec3(0.0), vec3(1.0));
    
    // Sample the vector field (xyz components contain the gradient)
    vec4 sample_value = texture(volume_texture, tex_coord);
    return sample_value.xyz;
}

// Reseed particle at a random valid position
void reseed_particle(uint idx, inout uint seed) {
    const int max_attempts = 32;
    vec3 pos = vec3(0.0);
    bool found = false;
    
    for (int attempt = 0; attempt < max_attempts; ++attempt) {
        // Generate random position
        pos = vec3(
            volume_min.x + random_float(seed) * (volume_max.x - volume_min.x),
            volume_min.y + random_float(seed) * (volume_max.y - volume_min.y),
            volume_min.z + random_float(seed) * (volume_max.z - volume_min.z)
        );
        
        // Check scalar value
        vec3 tex_coord = (pos - volume_min) / (volume_max - volume_min);
        vec4 sample_value = texture(volume_texture, tex_coord);
        float scalar_value = sample_value.w;
        
        if (scalar_value >= scalar_min && scalar_value <= scalar_max) {
            found = true;
            break;
        }
    }
    
    // If no valid position found, use random position anyway
    if (!found) {
        pos = vec3(
            volume_min.x + random_float(seed) * (volume_max.x - volume_min.x),
            volume_min.y + random_float(seed) * (volume_max.y - volume_min.y),
            volume_min.z + random_float(seed) * (volume_max.z - volume_min.z)
        );
    }
    
    float lifetime = min_lifetime + random_float(seed) * (max_lifetime - min_lifetime);
    
    particles[idx].position = vec4(pos, 0.0);
    particles[idx].velocity = vec4(0.0, 0.0, 0.0, lifetime);
    
    for (int i = 0; i < 8; ++i) {
        particles[idx].trail_pos[i] = vec4(pos, 0.0);
    }
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= num_particles) return;
    
    // Get current particle state
    vec3 pos = particles[idx].position.xyz;
    float age = particles[idx].position.w;
    vec3 vel = particles[idx].velocity.xyz;
    float lifetime = particles[idx].velocity.w;
    
    // Check if particle should be reseeded
    if (age >= lifetime) {
        uint seed = random_seed + idx * 1664525u + 1013904223u;
        reseed_particle(idx, seed);
        return;
    }
    
    // Check if particle is out of bounds
    if (any(lessThan(pos, volume_min)) || any(greaterThan(pos, volume_max))) {
        uint seed = random_seed + idx * 1664525u + 1013904223u;
        reseed_particle(idx, seed);
        return;
    }
    
    // Advect particle using RK4 integration
    vec3 k1 = sample_vector_field(pos);
    vec3 k2 = sample_vector_field(pos + k1 * dt * 0.5);
    vec3 k3 = sample_vector_field(pos + k2 * dt * 0.5);
    vec3 k4 = sample_vector_field(pos + k3 * dt);
    
    vec3 new_vel = (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0;
    vec3 new_pos = pos + new_vel * dt;
    
    // Update trail positions (shift and add new position)
    for (int i = 7; i > 0; --i) {
        particles[idx].trail_pos[i] = particles[idx].trail_pos[i - 1];
    }
    // Store previous position in trail (w component indicates valid trail point)
    particles[idx].trail_pos[0] = vec4(pos, 1.0);
    
    // Update particle
    particles[idx].position = vec4(new_pos, age + dt);
    particles[idx].velocity = vec4(new_vel, lifetime);
}

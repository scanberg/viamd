#version 430 core

#ifndef GROUP_SIZE
#define GROUP_SIZE 256
#endif

layout (local_size_x = GROUP_SIZE) in;

layout (std430, binding = 0) buffer particle_buffer {
    vec4 particles[];
};

layout (std140, binding = 0) uniform particle_params {
    uvec3 volume_dim;       // Volume dimensions
    uint  num_particles;    // Number of particles to seed
    vec3  volume_min;       // Volume AABB min
    float dt;               // Unused by seeding
    vec3  volume_max;       // Volume AABB max
    float scalar_min;       // Scalar threshold min
    float scalar_max;       // Scalar threshold max
    float min_lifetime;     // Minimum particle lifetime
    float max_lifetime;     // Maximum particle lifetime
    uint  random_seed;      // Random seed
    uint  force_seed;       // Force reseeding all particles
};

layout (binding = 0) uniform sampler3D volume_texture;

// Simple random number generator (PCG)
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float random_float(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) / 4294967296.0;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= num_particles) return;

    vec4 particle = particles[idx];

    vec3 pos = particle.xyz;
    float life = particle.w;

    if (force_seed == 1) {
        life = -1.0;
    }

    if (life > 0.0) {
        // Particle is still alive, no need to reseed
        return;
    }
    
    // Initialize random seed with global index and user seed
    uint seed = random_seed + idx * 1664525u + 1013904223u;
    
    // Try multiple times to find a valid position within scalar range
    const int max_attempts = 32;
    float scalar_value = 0.0;
    
    for (int attempt = 0; attempt < max_attempts; ++attempt) {
        // Generate random position within volume bounds
        pos = vec3(
            volume_min.x + random_float(seed) * (volume_max.x - volume_min.x),
            volume_min.y + random_float(seed) * (volume_max.y - volume_min.y),
            volume_min.z + random_float(seed) * (volume_max.z - volume_min.z)
        );
        
        // Convert to texture coordinates [0, 1]
        vec3 tex_coord = (pos - volume_min) / (volume_max - volume_min);
        
        // Sample the scalar value (in x component)
        vec4 sample_value = texture(volume_texture, tex_coord);
        scalar_value = sample_value.x;
        
        // Break if within desired range
        if (scalar_value >= scalar_min && scalar_value <= scalar_max) {
            break;
        }
    }
    
    // Generate random lifetime
    float lifetime = min_lifetime + random_float(seed) * (max_lifetime - min_lifetime);
    particles[idx] = vec4(pos, lifetime);
}

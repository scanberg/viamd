#pragma once

#include <core/md_vec_math.h>
#include <core/md_str.h>

namespace volume {

void initialize();
void shutdown();

mat4_t compute_model_to_world_matrix(vec3_t min_world_aabb, vec3_t max_world_aabb);
mat4_t compute_world_to_model_matrix(vec3_t min_world_aabb, vec3_t max_world_aabb);
mat4_t compute_texture_to_model_matrix(int dim_x, int dim_y, int dim_z);
mat4_t compute_model_to_texture_matrix(int dim_x, int dim_y, int dim_z);

// Simple transfer function 
void compute_transfer_function_texture_simple_ramp(uint32_t* texture, int implot_colormap, float alpha_scale = 1.0f, int resolution = 128);

void compute_transfer_function_texture_simple(uint32_t* texture, int implot_colormap, float alpha = 1.0f, int resolution = 128);


enum ramp_type_t {
    RAMP_TYPE_SAWTOOTH,         /* Alpha ramp: /|/|/|/|   */
    RAMP_TYPE_TRIANGLE,         /* Alpha ramp: /\/\/\/\   */
};

// Create a transfer function texture with an alpha ramp generated by an underlying function
// If you want a monotonic ramp (standard), you can for example use SAWTOOTH with a period of 1
void compute_transfer_function_texture(uint32_t* texture, int implot_colormap, ramp_type_t ramp_type = RAMP_TYPE_SAWTOOTH, float ramp_scale = 1.0f, float ramp_period = 1.0001f, int resolution = 128);

/*
    Renders a volumetric texture using OpenGL.
    - volume_texture: An OpenGL 3D texture containing the data
    - tf_texture:     An OpenGL 1D texture containing the transfer function
    - depth_texture:  An OpenGL 2D texture containing the depth data in the frame (for stopping ray traversal)
    - model_matrix:   Matrix containing model to world transformation of the volume, which is assumed to occupy a unit cube [0,1] in its model-space
    - view_matrix:    Matrix containing world to view transformation of the camera
    - proj_matrix:    Matrix containing view to clip transformation of the camera
    - density_scale:  global scaling of density
    - alpha_scale:    global alpha scaling of the transfer function
    - isosurface:     information on isovalues and associated colors
    - voxel_spacing:  spacing of voxels in world space
    - clip_planes:    define a subvolume (min, max)[0-1] which represents the visible portion of the volume
*/

struct RenderDesc {
    struct {
        uint32_t depth = 0;
        uint32_t color = 0;
        uint32_t width = 0;
        uint32_t height = 0;
        bool clear_color = false;
    } render_target;

    struct {
        uint32_t volume = 0;
        uint32_t tf_volume = 0;
        uint32_t tf = 0;
    } texture;

    struct {
        mat4_t model = {};
        mat4_t view = {};
        mat4_t proj = {};
        mat4_t inv_proj = {};
    } matrix;

    struct {
        vec3_t min = {0, 0, 0};
        vec3_t max = {1, 1, 1};
    } clip_volume;

    struct {
        // Enables temporal jittering of the ray-casting offset
        bool enabled = false;
    } temporal;

    struct {
        bool enabled = false;
        size_t count = 0;
        const float* values = NULL;
        const vec4_t* colors = NULL;
    } iso;

    struct {
        bool enabled = false;
    } dvr;

    struct {
        float min_value = 0.0f;
        float max_value = 1.0f;
    } tf;

    // A simplified shading model based on Cook-Torrance
    // Static enviromental radiance (uniformly lit from all directions)
    // 1 directional light positioned at {1,1,1} in viewspace

    // env_radiance: The uniformly incomming radiance from all directions
    // dir_radiance: The directional radiance incomming from a directional light
    // roughness: Approximates the micro-roughness of the surface
    // A value of 0.0 would approximate a perfectly smooth surface
    // A value of 1.0 would approximate a perfectly 'diffuse' surface

    // ior: corresponds to the Index of refraction of the iso surfaces.
    // A value of 1.5 is recommended and roughly approximates plastic

    struct {
        vec3_t env_radiance = {0,0,0};
        float roughness = 0.4f;
        vec3_t dir_radiance = {1,1,1};
        float ior = 1.5f;
    } shading;

    vec3_t voxel_spacing = {};
};

void render_volume(const RenderDesc& desc);

struct MapVolumeToSurfaceDesc {
    struct {
        uint32_t depth = 0;
        uint32_t color = 0;
        uint32_t width = 0;
        uint32_t height = 0;
    } render_target;

    struct {
        mat4_t inv_proj;
    } matrix;

    struct {
        mat4_t world_to_tex = {};
        uint32_t texture_id = 0;
    } volume;

    struct {
        uint32_t texture_id = 0;
        float min_value = 0.0f;
        float max_value = 1.0f;
    } tf;
};

// This is a wierd function.
// It samples the surface points provided as input depth, samples the corresponding points in the supplied volume
// Then maps the sampled volume value through the supplied transfer function and outputs the color to the supplied render target.
void map_volume_to_surface(const MapVolumeToSurfaceDesc& desc);


}  // namespace volume

diff --git src/md_trexio.c src/md_trexio.c
new file mode 100644
index 0000000..79f437f
--- /dev/null
+++ src/md_trexio.c
@@ -0,0 +1,861 @@
+﻿#include "md_trexio.h"
+
+#include <core/md_allocator.h>
+#include <core/md_array.h>
+#include <core/md_log.h>
+#include <core/md_str.h>
+#include <md_system.h>
+
+#include <string.h>
+#include <math.h>
+
+#ifdef MD_TREXIO
+#include <trexio.h>
+
+#define BOHR_TO_ANGSTROM 0.529177210903
+#define ANGSTROM_TO_BOHR 1.88972612456506
+
+struct md_trexio_t {
+    md_allocator_i* alloc;
+    trexio_t* file;
+    
+    // Nucleus data
+    int64_t nucleus_num;
+    double* nucleus_coord;      // [3 * nucleus_num] in Angstrom
+    double* nucleus_charge;     // [nucleus_num]
+    char** nucleus_label;       // [nucleus_num]
+    double nucleus_repulsion;
+    
+    // Basis set data
+    int32_t basis_shell_num;
+    int32_t basis_prim_num;
+    char basis_type[32];
+    int32_t* basis_nucleus_index;   // [basis_shell_num]
+    int32_t* basis_shell_ang_mom;   // [basis_shell_num]
+    double* basis_shell_factor;     // [basis_shell_num]
+    int32_t* basis_shell_index;     // [basis_prim_num]
+    double* basis_exponent;         // [basis_prim_num]
+    double* basis_coefficient;      // [basis_prim_num]
+    double* basis_prim_factor;      // [basis_prim_num]
+    
+    // AO data
+    int32_t ao_num;
+    
+    // MO data
+    int32_t mo_num;
+    double* mo_coefficient;     // [ao_num * mo_num]
+    double* mo_energy;          // [mo_num]
+    double* mo_occupation;      // [mo_num]
+    char** mo_class;            // [mo_num]
+    char** mo_symmetry;         // [mo_num]
+    
+    // Electron data
+    int32_t num_up_electrons;
+    int32_t num_down_electrons;
+};
+
+md_trexio_t* md_trexio_create(md_allocator_i* alloc) {
+    ASSERT(alloc);
+    md_trexio_t* trexio = (md_trexio_t*)md_alloc(alloc, sizeof(md_trexio_t));
+    MEMSET(trexio, 0, sizeof(md_trexio_t));
+    trexio->alloc = alloc;
+    return trexio;
+}
+
+static void free_string_array(char** arr, size_t count, md_allocator_i* alloc) {
+    if (arr) {
+        for (size_t i = 0; i < count; ++i) {
+            if (arr[i]) {
+                md_free(alloc, arr[i], strlen(arr[i]) + 1);
+            }
+        }
+        md_free(alloc, arr, count * sizeof(char*));
+    }
+}
+
+void md_trexio_reset(md_trexio_t* trexio) {
+    if (!trexio) return;
+    
+    md_allocator_i* alloc = trexio->alloc;
+    
+    if (trexio->file) {
+        trexio_close(trexio->file);
+        trexio->file = NULL;
+    }
+    
+    // Free nucleus data
+    if (trexio->nucleus_coord) md_free(alloc, trexio->nucleus_coord, 3 * trexio->nucleus_num * sizeof(double));
+    if (trexio->nucleus_charge) md_free(alloc, trexio->nucleus_charge, trexio->nucleus_num * sizeof(double));
+    free_string_array(trexio->nucleus_label, trexio->nucleus_num, alloc);
+    
+    // Free basis data
+    if (trexio->basis_nucleus_index) md_free(alloc, trexio->basis_nucleus_index, trexio->basis_shell_num * sizeof(int32_t));
+    if (trexio->basis_shell_ang_mom) md_free(alloc, trexio->basis_shell_ang_mom, trexio->basis_shell_num * sizeof(int32_t));
+    if (trexio->basis_shell_factor) md_free(alloc, trexio->basis_shell_factor, trexio->basis_shell_num * sizeof(double));
+    if (trexio->basis_shell_index) md_free(alloc, trexio->basis_shell_index, trexio->basis_prim_num * sizeof(int32_t));
+    if (trexio->basis_exponent) md_free(alloc, trexio->basis_exponent, trexio->basis_prim_num * sizeof(double));
+    if (trexio->basis_coefficient) md_free(alloc, trexio->basis_coefficient, trexio->basis_prim_num * sizeof(double));
+    if (trexio->basis_prim_factor) md_free(alloc, trexio->basis_prim_factor, trexio->basis_prim_num * sizeof(double));
+    
+    // Free MO data
+    if (trexio->mo_coefficient) md_free(alloc, trexio->mo_coefficient, trexio->ao_num * trexio->mo_num * sizeof(double));
+    if (trexio->mo_energy) md_free(alloc, trexio->mo_energy, trexio->mo_num * sizeof(double));
+    if (trexio->mo_occupation) md_free(alloc, trexio->mo_occupation, trexio->mo_num * sizeof(double));
+    free_string_array(trexio->mo_class, trexio->mo_num, alloc);
+    free_string_array(trexio->mo_symmetry, trexio->mo_num, alloc);
+    
+    MEMSET(trexio, 0, sizeof(md_trexio_t));
+    trexio->alloc = alloc;
+}
+
+void md_trexio_destroy(md_trexio_t* trexio) {
+    if (!trexio) return;
+    md_allocator_i* alloc = trexio->alloc;
+    md_trexio_reset(trexio);
+    md_free(alloc, trexio, sizeof(md_trexio_t));
+}
+
+bool md_trexio_parse_file(md_trexio_t* trexio, str_t filename) {
+    if (!trexio) {
+        MD_LOG_ERROR("TREXIO: Invalid trexio object (NULL pointer)");
+        return false;
+    }
+    
+    if (!filename.ptr || filename.len == 0) {
+        MD_LOG_ERROR("TREXIO: Invalid filename");
+        return false;
+    }
+    
+    // Reset any existing data
+    md_trexio_reset(trexio);
+    
+    // Convert str_t to null-terminated string (with bounds check)
+    if (filename.len > 4096) {
+        MD_LOG_ERROR("TREXIO: Filename too long (%lld characters, max 4096)", (long long)filename.len);
+        return false;
+    }
+    
+    char* path = (char*)md_alloc(trexio->alloc, filename.len + 1);
+    if (!path) {
+        MD_LOG_ERROR("TREXIO: Failed to allocate memory for filename");
+        return false;
+    }
+    MEMCPY(path, filename.ptr, filename.len);
+    path[filename.len] = '\0';
+    
+    MD_LOG_INFO("TREXIO: Opening file: %s", path);
+    
+    // Open TREXIO file (auto-detect backend)
+    trexio_exit_code rc;
+    trexio->file = trexio_open(path, 'r', TREXIO_AUTO, &rc);
+    md_free(trexio->alloc, path, filename.len + 1);
+    
+    if (rc != TREXIO_SUCCESS || !trexio->file) {
+        MD_LOG_ERROR("TREXIO: Failed to open file: %s (error code: %d)", trexio_string_of_error(rc), rc);
+        return false;
+    }
+    
+    md_allocator_i* alloc = trexio->alloc;
+    
+    // Read nucleus data (required)
+    MD_LOG_INFO("TREXIO: Reading nuclear data...");
+    rc = trexio_read_nucleus_num(trexio->file, &trexio->nucleus_num);
+    if (rc != TREXIO_SUCCESS) {
+        MD_LOG_ERROR("TREXIO: Failed to read nucleus_num (required field): %s", trexio_string_of_error(rc));
+        goto error;
+    }
+    
+    if (trexio->nucleus_num <= 0) {
+        MD_LOG_ERROR("TREXIO: Invalid nucleus_num: %lld (must be > 0)", (long long)trexio->nucleus_num);
+        goto error;
+    }
+    
+    if (trexio->nucleus_num > 1000000) {
+        MD_LOG_ERROR("TREXIO: Nucleus count too large: %lld (max 1000000 for safety)", (long long)trexio->nucleus_num);
+        goto error;
+    }
+    
+    MD_LOG_INFO("TREXIO: Found %lld atoms", (long long)trexio->nucleus_num);
+    
+    if (trexio->nucleus_num > 0) {
+        // Allocate and read coordinates (stored in Bohr in TREXIO, convert to Angstrom)
+        trexio->nucleus_coord = (double*)md_alloc(alloc, 3 * trexio->nucleus_num * sizeof(double));
+        if (!trexio->nucleus_coord) {
+            MD_LOG_ERROR("TREXIO: Failed to allocate memory for coordinates");
+            goto error;
+        }
+        
+        rc = trexio_read_nucleus_coord(trexio->file, trexio->nucleus_coord);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_ERROR("TREXIO: Failed to read nucleus_coord (required field): %s", trexio_string_of_error(rc));
+            goto error;
+        }
+        
+        // Convert from Bohr to Angstrom and validate coordinates
+        for (int64_t i = 0; i < 3 * trexio->nucleus_num; ++i) {
+            trexio->nucleus_coord[i] *= BOHR_TO_ANGSTROM;
+            // Check for NaN or Inf values
+            if (!isfinite(trexio->nucleus_coord[i])) {
+                MD_LOG_ERROR("TREXIO: Invalid coordinate value at index %lld (NaN or Inf)", (long long)i);
+                goto error;
+            }
+        }
+        
+        // Read charges (required)
+        trexio->nucleus_charge = (double*)md_alloc(alloc, trexio->nucleus_num * sizeof(double));
+        if (!trexio->nucleus_charge) {
+            MD_LOG_ERROR("TREXIO: Failed to allocate memory for charges");
+            goto error;
+        }
+        
+        rc = trexio_read_nucleus_charge(trexio->file, trexio->nucleus_charge);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_ERROR("TREXIO: Failed to read nucleus_charge (required field): %s", trexio_string_of_error(rc));
+            goto error;
+        }
+        
+        // Validate charges
+        for (int64_t i = 0; i < trexio->nucleus_num; ++i) {
+            if (trexio->nucleus_charge[i] < 0.0 || trexio->nucleus_charge[i] > 118.0) {
+                MD_LOG_INFO("TREXIO: Warning - unusual nuclear charge %g at atom %lld", 
+                           trexio->nucleus_charge[i], (long long)i);
+            }
+        }
+        
+        // Read labels (optional but recommended)
+        int32_t max_str_len = 32;
+        char* labels_buffer = (char*)md_alloc(alloc, trexio->nucleus_num * max_str_len);
+        if (!labels_buffer) {
+            MD_LOG_INFO("TREXIO: Warning - Failed to allocate memory for labels, skipping");
+        } else {
+            rc = trexio_read_nucleus_label(trexio->file, labels_buffer, max_str_len);
+            if (rc == TREXIO_SUCCESS) {
+                trexio->nucleus_label = (char**)md_alloc(alloc, trexio->nucleus_num * sizeof(char*));
+                if (trexio->nucleus_label) {
+                    for (int64_t i = 0; i < trexio->nucleus_num; ++i) {
+                        const char* label = labels_buffer + i * max_str_len;
+                        size_t len = strnlen(label, max_str_len);  // Use strnlen for safety
+                        if (len > 0) {
+                            trexio->nucleus_label[i] = (char*)md_alloc(alloc, len + 1);
+                            if (trexio->nucleus_label[i]) {
+                                MEMCPY(trexio->nucleus_label[i], label, len);
+                                trexio->nucleus_label[i][len] = '\0';
+                            }
+                        } else {
+                            trexio->nucleus_label[i] = NULL;
+                        }
+                    }
+                }
+            } else {
+                MD_LOG_INFO("TREXIO: Warning - nucleus labels not present (optional field)");
+            }
+            md_free(alloc, labels_buffer, trexio->nucleus_num * max_str_len);
+        }
+    }
+    
+    // Read nuclear repulsion energy (optional)
+    rc = trexio_read_nucleus_repulsion(trexio->file, &trexio->nucleus_repulsion);
+    if (rc != TREXIO_SUCCESS) {
+        MD_LOG_INFO("TREXIO: Nuclear repulsion energy not present (optional field)");
+        trexio->nucleus_repulsion = 0.0;
+    } else {
+        MD_LOG_INFO("TREXIO: Nuclear repulsion energy: %g Hartree", trexio->nucleus_repulsion);
+    }
+    
+    // Read basis set data (optional, may not be present)
+    MD_LOG_INFO("TREXIO: Reading basis set data (optional)...");
+    rc = trexio_read_basis_shell_num(trexio->file, &trexio->basis_shell_num);
+    if (rc == TREXIO_SUCCESS && trexio->basis_shell_num > 0) {
+        MD_LOG_INFO("TREXIO: Found %d basis shells", (int)trexio->basis_shell_num);
+        
+        // Validate basis shell count
+        if (trexio->basis_shell_num > 100000) {
+            MD_LOG_INFO("TREXIO: Warning - very large basis set (%d shells), may cause performance issues",
+                       (int)trexio->basis_shell_num);
+        }
+        
+        rc = trexio_read_basis_prim_num(trexio->file, &trexio->basis_prim_num);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: basis_shell_num present but basis_prim_num missing (skipping basis data)");
+            goto skip_basis;
+        }
+        
+        MD_LOG_INFO("TREXIO: Found %d basis primitives", (int)trexio->basis_prim_num);
+        
+        // Read basis type
+        rc = trexio_read_basis_type(trexio->file, trexio->basis_type, sizeof(trexio->basis_type));
+        if (rc != TREXIO_SUCCESS) {
+            strcpy(trexio->basis_type, "Gaussian");  // Default assumption
+        }
+        
+        // Allocate and read basis arrays
+        trexio->basis_nucleus_index = (int32_t*)md_alloc(alloc, trexio->basis_shell_num * sizeof(int32_t));
+        trexio->basis_shell_ang_mom = (int32_t*)md_alloc(alloc, trexio->basis_shell_num * sizeof(int32_t));
+        trexio->basis_shell_factor = (double*)md_alloc(alloc, trexio->basis_shell_num * sizeof(double));
+        trexio->basis_shell_index = (int32_t*)md_alloc(alloc, trexio->basis_prim_num * sizeof(int32_t));
+        trexio->basis_exponent = (double*)md_alloc(alloc, trexio->basis_prim_num * sizeof(double));
+        trexio->basis_coefficient = (double*)md_alloc(alloc, trexio->basis_prim_num * sizeof(double));
+        trexio->basis_prim_factor = (double*)md_alloc(alloc, trexio->basis_prim_num * sizeof(double));
+        
+        rc = trexio_read_basis_nucleus_index(trexio->file, trexio->basis_nucleus_index);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: Failed to read basis_nucleus_index: %s", trexio_string_of_error(rc));
+            goto skip_basis;
+        }
+        
+        rc = trexio_read_basis_shell_ang_mom(trexio->file, trexio->basis_shell_ang_mom);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: Failed to read basis_shell_ang_mom: %s", trexio_string_of_error(rc));
+            goto skip_basis;
+        }
+        
+        rc = trexio_read_basis_shell_factor(trexio->file, trexio->basis_shell_factor);
+        if (rc != TREXIO_SUCCESS) {
+            // Optional field, set to 1.0
+            for (int64_t i = 0; i < trexio->basis_shell_num; ++i) {
+                trexio->basis_shell_factor[i] = 1.0;
+            }
+        }
+        
+        rc = trexio_read_basis_shell_index(trexio->file, trexio->basis_shell_index);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: Failed to read basis_shell_index: %s", trexio_string_of_error(rc));
+            goto skip_basis;
+        }
+        
+        rc = trexio_read_basis_exponent(trexio->file, trexio->basis_exponent);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: Failed to read basis_exponent: %s", trexio_string_of_error(rc));
+            goto skip_basis;
+        }
+        
+        rc = trexio_read_basis_coefficient(trexio->file, trexio->basis_coefficient);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: Failed to read basis_coefficient: %s", trexio_string_of_error(rc));
+            goto skip_basis;
+        }
+        
+        rc = trexio_read_basis_prim_factor(trexio->file, trexio->basis_prim_factor);
+        if (rc != TREXIO_SUCCESS) {
+            // Optional field, set to 1.0
+            for (int64_t i = 0; i < trexio->basis_prim_num; ++i) {
+                trexio->basis_prim_factor[i] = 1.0;
+            }
+        }
+    }
+skip_basis:
+    
+    // Read AO number (optional)
+    MD_LOG_INFO("TREXIO: Reading atomic orbital data (optional)...");
+    rc = trexio_read_ao_num(trexio->file, &trexio->ao_num);
+    if (rc != TREXIO_SUCCESS) {
+        MD_LOG_INFO("TREXIO: AO count not present (optional field)");
+        trexio->ao_num = 0;
+    } else {
+        MD_LOG_INFO("TREXIO: Found %d atomic orbitals", (int)trexio->ao_num);
+    }
+    
+    // Read MO data (optional but commonly present)
+    MD_LOG_INFO("TREXIO: Reading molecular orbital data (optional)...");
+    rc = trexio_read_mo_num(trexio->file, &trexio->mo_num);
+    if (rc == TREXIO_SUCCESS && trexio->mo_num > 0 && trexio->ao_num > 0) {
+        MD_LOG_INFO("TREXIO: Found %d molecular orbitals", (int)trexio->mo_num);
+        
+        // Validate MO/AO sizes for memory safety
+        if ((int64_t)trexio->ao_num * (int64_t)trexio->mo_num > 100000000) {
+            MD_LOG_INFO("TREXIO: Warning - MO coefficient matrix very large (%d x %d), skipping for memory safety",
+                       (int)trexio->ao_num, (int)trexio->mo_num);
+            goto skip_mo;
+        }
+        
+        // Allocate and read MO coefficients
+        size_t mo_coeff_size = (size_t)trexio->ao_num * (size_t)trexio->mo_num * sizeof(double);
+        MD_LOG_INFO("TREXIO: Allocating %.2f MB for MO coefficients", mo_coeff_size / (1024.0 * 1024.0));
+        trexio->mo_coefficient = (double*)md_alloc(alloc, mo_coeff_size);
+        if (!trexio->mo_coefficient) {
+            MD_LOG_INFO("TREXIO: Failed to allocate memory for MO coefficients, skipping");
+            goto skip_mo;
+        }
+        
+        rc = trexio_read_mo_coefficient(trexio->file, trexio->mo_coefficient);
+        if (rc != TREXIO_SUCCESS) {
+            MD_LOG_INFO("TREXIO: Failed to read mo_coefficient: %s", trexio_string_of_error(rc));
+            md_free(alloc, trexio->mo_coefficient, mo_coeff_size);
+            trexio->mo_coefficient = NULL;
+            goto skip_mo;
+        }
+        
+        MD_LOG_INFO("TREXIO: Successfully loaded MO coefficients");
+        
+        // Read MO energies (optional but commonly present)
+        trexio->mo_energy = (double*)md_alloc(alloc, trexio->mo_num * sizeof(double));
+        if (trexio->mo_energy) {
+            rc = trexio_read_mo_energy(trexio->file, trexio->mo_energy);
+            if (rc != TREXIO_SUCCESS) {
+                MD_LOG_INFO("TREXIO: MO energies not present (optional field)");
+                md_free(alloc, trexio->mo_energy, trexio->mo_num * sizeof(double));
+                trexio->mo_energy = NULL;
+            } else {
+                MD_LOG_INFO("TREXIO: Successfully loaded MO energies");
+            }
+        }
+        
+        // Read MO occupations (optional but commonly present)
+        trexio->mo_occupation = (double*)md_alloc(alloc, trexio->mo_num * sizeof(double));
+        if (trexio->mo_occupation) {
+            rc = trexio_read_mo_occupation(trexio->file, trexio->mo_occupation);
+            if (rc != TREXIO_SUCCESS) {
+                MD_LOG_INFO("TREXIO: MO occupations not present (optional field)");
+                md_free(alloc, trexio->mo_occupation, trexio->mo_num * sizeof(double));
+                trexio->mo_occupation = NULL;
+            } else {
+                MD_LOG_INFO("TREXIO: Successfully loaded MO occupations");
+            }
+        }
+    } else if (rc != TREXIO_SUCCESS) {
+        MD_LOG_INFO("TREXIO: MO data not present (optional field)");
+    }
+skip_mo:
+    
+    // Read electron numbers (optional but commonly present)
+    MD_LOG_INFO("TREXIO: Reading electron configuration (optional)...");
+    rc = trexio_read_electron_up_num(trexio->file, &trexio->num_up_electrons);
+    if (rc != TREXIO_SUCCESS) {
+        MD_LOG_INFO("TREXIO: Up-spin electron count not present (optional field)");
+        trexio->num_up_electrons = 0;
+    }
+    
+    rc = trexio_read_electron_dn_num(trexio->file, &trexio->num_down_electrons);
+    if (rc != TREXIO_SUCCESS) {
+        MD_LOG_INFO("TREXIO: Down-spin electron count not present (optional field)");
+        trexio->num_down_electrons = 0;
+    }
+    
+    if (trexio->num_up_electrons > 0 || trexio->num_down_electrons > 0) {
+        MD_LOG_INFO("TREXIO: Electron configuration: %d up, %d down (total: %d)",
+                   (int)trexio->num_up_electrons, (int)trexio->num_down_electrons,
+                   (int)(trexio->num_up_electrons + trexio->num_down_electrons));
+    }
+    
+    MD_LOG_INFO("TREXIO: Successfully loaded file with %lld atoms", (long long)trexio->nucleus_num);
+    return true;
+    
+error:
+    md_trexio_reset(trexio);
+    return false;
+}
+
+// Accessor functions
+
+size_t md_trexio_number_of_atoms(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->nucleus_num : 0;
+}
+
+const double* md_trexio_atom_coordinates(const md_trexio_t* trexio) {
+    return trexio ? trexio->nucleus_coord : NULL;
+}
+
+const double* md_trexio_atomic_charges(const md_trexio_t* trexio) {
+    return trexio ? trexio->nucleus_charge : NULL;
+}
+
+const char** md_trexio_atom_labels(const md_trexio_t* trexio) {
+    return trexio ? (const char**)trexio->nucleus_label : NULL;
+}
+
+double md_trexio_nuclear_repulsion_energy(const md_trexio_t* trexio) {
+    return trexio ? trexio->nucleus_repulsion : 0.0;
+}
+
+size_t md_trexio_basis_shell_num(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->basis_shell_num : 0;
+}
+
+size_t md_trexio_basis_prim_num(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->basis_prim_num : 0;
+}
+
+size_t md_trexio_number_of_aos(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->ao_num : 0;
+}
+
+str_t md_trexio_basis_type(const md_trexio_t* trexio) {
+    if (trexio && trexio->basis_type[0]) {
+        return (str_t){trexio->basis_type, strlen(trexio->basis_type)};
+    }
+    return (str_t){0};
+}
+
+size_t md_trexio_mo_num(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->mo_num : 0;
+}
+
+const double* md_trexio_mo_coefficient(const md_trexio_t* trexio) {
+    return trexio ? trexio->mo_coefficient : NULL;
+}
+
+const double* md_trexio_mo_energy(const md_trexio_t* trexio) {
+    return trexio ? trexio->mo_energy : NULL;
+}
+
+const double* md_trexio_mo_occupation(const md_trexio_t* trexio) {
+    return trexio ? trexio->mo_occupation : NULL;
+}
+
+const char** md_trexio_mo_class(const md_trexio_t* trexio) {
+    return trexio ? (const char**)trexio->mo_class : NULL;
+}
+
+const char** md_trexio_mo_symmetry(const md_trexio_t* trexio) {
+    return trexio ? (const char**)trexio->mo_symmetry : NULL;
+}
+
+size_t md_trexio_num_up_electrons(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->num_up_electrons : 0;
+}
+
+size_t md_trexio_num_down_electrons(const md_trexio_t* trexio) {
+    return trexio ? (size_t)trexio->num_down_electrons : 0;
+}
+
+// GTO extraction functions
+
+bool md_trexio_extract_ao_data(md_gto_data_t* out_ao_data, const md_trexio_t* trexio, 
+                                 double cutoff_value, md_allocator_i* alloc) {
+    // This would require implementing the conversion from TREXIO basis data to md_gto_data_t
+    // This is a placeholder for now
+    (void)out_ao_data;
+    (void)trexio;
+    (void)cutoff_value;
+    (void)alloc;
+    MD_LOG_INFO("TREXIO: md_trexio_extract_ao_data not yet implemented");
+    return false;
+}
+
+size_t md_trexio_mo_gto_count(const md_trexio_t* trexio) {
+    // Placeholder
+    (void)trexio;
+    return 0;
+}
+
+size_t md_trexio_mo_gto_extract(md_gto_t gtos[], const md_trexio_t* trexio, 
+                                 size_t mo_idx, double value_cutoff) {
+    // This would require implementing the conversion from MO coefficients to GTOs
+    // This is a placeholder for now
+    (void)gtos;
+    (void)trexio;
+    (void)mo_idx;
+    (void)value_cutoff;
+    MD_LOG_INFO("TREXIO: md_trexio_mo_gto_extract not yet implemented");
+    return 0;
+}
+
+// System initialization
+
+bool md_trexio_system_init(md_system_t* sys, const md_trexio_t* trexio, md_allocator_i* alloc) {
+    if (!sys) {
+        MD_LOG_ERROR("TREXIO: NULL system pointer in system_init");
+        return false;
+    }
+    if (!trexio) {
+        MD_LOG_ERROR("TREXIO: NULL trexio pointer in system_init");
+        return false;
+    }
+    if (!alloc) {
+        MD_LOG_ERROR("TREXIO: NULL allocator in system_init");
+        return false;
+    }
+    
+    MEMSET(sys, 0, sizeof(md_system_t));
+    
+    const size_t num_atoms = md_trexio_number_of_atoms(trexio);
+    if (num_atoms == 0) {
+        MD_LOG_ERROR("TREXIO: No atoms in file (cannot initialize system)");
+        return false;
+    }
+    
+    if (num_atoms > 10000000) {
+        MD_LOG_ERROR("TREXIO: Too many atoms (%zu) for safe system initialization", num_atoms);
+        return false;
+    }
+    
+    MD_LOG_INFO("TREXIO: Initializing system with %zu atoms", num_atoms);
+    
+    const double* coords = md_trexio_atom_coordinates(trexio);
+    const double* charges = md_trexio_atomic_charges(trexio);
+    const char** labels = md_trexio_atom_labels(trexio);
+    
+    if (!coords) {
+        MD_LOG_ERROR("TREXIO: Missing required coordinate data");
+        return false;
+    }
+    if (!charges) {
+        MD_LOG_ERROR("TREXIO: Missing required charge data");
+        return false;
+    }
+    
+    // Allocate atom data with NULL checks
+    sys->atom.count = num_atoms;
+    sys->atom.x = (float*)md_alloc(alloc, num_atoms * sizeof(float));
+    sys->atom.y = (float*)md_alloc(alloc, num_atoms * sizeof(float));
+    sys->atom.z = (float*)md_alloc(alloc, num_atoms * sizeof(float));
+    sys->atom.type_idx = (md_atom_type_idx_t*)md_alloc(alloc, num_atoms * sizeof(md_atom_type_idx_t));
+    sys->atom.flags = (md_flags_t*)md_alloc(alloc, num_atoms * sizeof(md_flags_t));
+    
+    if (!sys->atom.x || !sys->atom.y || !sys->atom.z || !sys->atom.type_idx || !sys->atom.flags) {
+        MD_LOG_ERROR("TREXIO: Failed to allocate memory for atom data");
+        return false;
+    }
+    
+    // Copy coordinates
+    for (size_t i = 0; i < num_atoms; ++i) {
+        sys->atom.x[i] = (float)coords[i * 3 + 0];
+        sys->atom.y[i] = (float)coords[i * 3 + 1];
+        sys->atom.z[i] = (float)coords[i * 3 + 2];
+        sys->atom.flags[i] = 0;
+    }
+    
+    // Set up atom types based on atomic numbers
+    sys->atom.type.count = 0;
+    
+    // Create one type per unique element (atomic number)
+    for (size_t i = 0; i < num_atoms; ++i) {
+        md_atomic_number_t atomic_num = (md_atomic_number_t)charges[i];
+        
+        // Validate atomic number
+        if (atomic_num < 1 || atomic_num > 118) {
+            MD_LOG_INFO("TREXIO: Warning - unusual atomic number %d at atom %zu, using as-is", 
+                       (int)atomic_num, i);
+        }
+        
+        // Find or create atom type
+        size_t type_idx = 0;
+        bool found = false;
+        for (size_t j = 0; j < sys->atom.type.count; ++j) {
+            if (sys->atom.type.z && sys->atom.type.z[j] == atomic_num) {
+                type_idx = j;
+                found = true;
+                break;
+            }
+        }
+        
+        if (!found) {
+            // Create new type
+            type_idx = sys->atom.type.count++;
+            
+            // Reallocate type arrays
+            sys->atom.type.z = (md_atomic_number_t*)md_realloc(alloc, sys->atom.type.z, 
+                                                                (type_idx) * sizeof(md_atomic_number_t),
+                                                                (type_idx + 1) * sizeof(md_atomic_number_t));
+            sys->atom.type.name = (md_label_t*)md_realloc(alloc, sys->atom.type.name,
+                                                           (type_idx) * sizeof(md_label_t),
+                                                           (type_idx + 1) * sizeof(md_label_t));
+            sys->atom.type.mass = (float*)md_realloc(alloc, sys->atom.type.mass,
+                                                      (type_idx) * sizeof(float),
+                                                      (type_idx + 1) * sizeof(float));
+            sys->atom.type.radius = (float*)md_realloc(alloc, sys->atom.type.radius,
+                                                        (type_idx) * sizeof(float),
+                                                        (type_idx + 1) * sizeof(float));
+            
+            sys->atom.type.z[type_idx] = atomic_num;
+            
+            // Set atom name from label if available, otherwise use element symbol
+            if (labels && labels[i]) {
+                const char* label = labels[i];
+                size_t label_len = strlen(label);
+                if (label_len > 6) label_len = 6;  // md_label_t max is 6 chars
+                MEMCPY(sys->atom.type.name[type_idx].buf, label, label_len);
+                sys->atom.type.name[type_idx].buf[label_len] = '\0';
+                sys->atom.type.name[type_idx].len = (uint8_t)label_len;
+            } else {
+                // Use default element name based on atomic number
+                char elem_name[7];
+                int len = snprintf(elem_name, sizeof(elem_name), "%d", atomic_num);
+                if (len > 6) len = 6;
+                MEMCPY(sys->atom.type.name[type_idx].buf, elem_name, len);
+                sys->atom.type.name[type_idx].buf[len] = '\0';
+                sys->atom.type.name[type_idx].len = (uint8_t)len;
+            }
+            
+            // Set default mass and radius (simplified - should use periodic table)
+            sys->atom.type.mass[type_idx] = (float)atomic_num;  // Approximation
+            sys->atom.type.radius[type_idx] = 1.5f;  // Default VdW radius
+        }
+        
+        sys->atom.type_idx[i] = (md_atom_type_idx_t)type_idx;
+    }
+    
+    return true;
+}
+
+// System loader interface
+
+static bool trexio_loader_init(md_system_t* sys, str_t filename, const void* arg, md_allocator_i* alloc) {
+    (void)arg;  // Not used for TREXIO
+    
+    md_trexio_t* trexio = md_trexio_create(alloc);
+    if (!trexio) {
+        MD_LOG_ERROR("TREXIO: Failed to create TREXIO object");
+        return false;
+    }
+    
+    bool result = false;
+    if (md_trexio_parse_file(trexio, filename)) {
+        result = md_trexio_system_init(sys, trexio, alloc);
+    }
+    
+    md_trexio_destroy(trexio);
+    return result;
+}
+
+static md_system_loader_i trexio_loader = {
+    trexio_loader_init
+};
+
+md_system_loader_i* md_trexio_system_loader(void) {
+    return &trexio_loader;
+}
+
+#else  // !MD_TREXIO
+
+// Stub implementations when TREXIO is not enabled
+
+md_trexio_t* md_trexio_create(md_allocator_i* alloc) {
+    (void)alloc;
+    return NULL;
+}
+
+void md_trexio_reset(md_trexio_t* trexio) {
+    (void)trexio;
+}
+
+void md_trexio_destroy(md_trexio_t* trexio) {
+    (void)trexio;
+}
+
+bool md_trexio_parse_file(md_trexio_t* trexio, str_t filename) {
+    (void)trexio;
+    (void)filename;
+    return false;
+}
+
+size_t md_trexio_number_of_atoms(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+const double* md_trexio_atom_coordinates(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+const double* md_trexio_atomic_charges(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+const char** md_trexio_atom_labels(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+double md_trexio_nuclear_repulsion_energy(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0.0;
+}
+
+size_t md_trexio_basis_shell_num(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+size_t md_trexio_basis_prim_num(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+size_t md_trexio_number_of_aos(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+str_t md_trexio_basis_type(const md_trexio_t* trexio) {
+    (void)trexio;
+    return (str_t){0};
+}
+
+size_t md_trexio_mo_num(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+const double* md_trexio_mo_coefficient(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+const double* md_trexio_mo_energy(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+const double* md_trexio_mo_occupation(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+const char** md_trexio_mo_class(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+const char** md_trexio_mo_symmetry(const md_trexio_t* trexio) {
+    (void)trexio;
+    return NULL;
+}
+
+size_t md_trexio_num_up_electrons(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+size_t md_trexio_num_down_electrons(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+bool md_trexio_extract_ao_data(md_gto_data_t* out_ao_data, const md_trexio_t* trexio, 
+                                 double cutoff_value, md_allocator_i* alloc) {
+    (void)out_ao_data;
+    (void)trexio;
+    (void)cutoff_value;
+    (void)alloc;
+    return false;
+}
+
+size_t md_trexio_mo_gto_count(const md_trexio_t* trexio) {
+    (void)trexio;
+    return 0;
+}
+
+size_t md_trexio_mo_gto_extract(md_gto_t gtos[], const md_trexio_t* trexio, 
+                                 size_t mo_idx, double value_cutoff) {
+    (void)gtos;
+    (void)trexio;
+    (void)mo_idx;
+    (void)value_cutoff;
+    return 0;
+}
+
+bool md_trexio_system_init(md_system_t* sys, const md_trexio_t* trexio, md_allocator_i* alloc) {
+    (void)sys;
+    (void)trexio;
+    (void)alloc;
+    return false;
+}
+
+md_system_loader_i* md_trexio_system_loader(void) {
+    return NULL;
+}
+
+#endif  // MD_TREXIO
diff --git src/md_trexio.h src/md_trexio.h
new file mode 100644
index 0000000..32c63b3
--- /dev/null
+++ src/md_trexio.h
@@ -0,0 +1,117 @@
+﻿#pragma once
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+#include <md_types.h>
+#include <md_gto.h>
+#include <core/md_str.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct md_allocator_i;
+struct md_system_t;
+struct md_system_loader_i;
+
+typedef struct md_trexio_t md_trexio_t;
+
+// Basic operations
+
+// Create a new TREXIO object
+struct md_trexio_t* md_trexio_create(struct md_allocator_i* alloc);
+
+// Reset the TREXIO object (clear all data)
+void md_trexio_reset(struct md_trexio_t* trexio);
+
+// Destroy the TREXIO object and free all memory
+void md_trexio_destroy(struct md_trexio_t* trexio);
+
+// Parse a TREXIO file (.h5 or .trexio format)
+bool md_trexio_parse_file(struct md_trexio_t* trexio, str_t filename);
+
+// Nucleus (atomic) data
+
+// Get the number of atoms
+size_t md_trexio_number_of_atoms(const struct md_trexio_t* trexio);
+
+// Get atom coordinates in Angstrom (array of size 3 * num_atoms: x1,y1,z1, x2,y2,z2, ...)
+const double* md_trexio_atom_coordinates(const struct md_trexio_t* trexio);
+
+// Get atomic charges (array of size num_atoms)
+const double* md_trexio_atomic_charges(const struct md_trexio_t* trexio);
+
+// Get atom labels (array of strings, size num_atoms)
+const char** md_trexio_atom_labels(const struct md_trexio_t* trexio);
+
+// Get nuclear repulsion energy in Hartree
+double md_trexio_nuclear_repulsion_energy(const struct md_trexio_t* trexio);
+
+// Basis set data
+
+// Get the number of shells in the basis set
+size_t md_trexio_basis_shell_num(const struct md_trexio_t* trexio);
+
+// Get the number of primitives in the basis set
+size_t md_trexio_basis_prim_num(const struct md_trexio_t* trexio);
+
+// Get the number of atomic orbitals
+size_t md_trexio_number_of_aos(const struct md_trexio_t* trexio);
+
+// Get basis set type string
+str_t md_trexio_basis_type(const struct md_trexio_t* trexio);
+
+// Extract atomic orbital Gaussian data
+bool md_trexio_extract_ao_data(md_gto_data_t* out_ao_data, const struct md_trexio_t* trexio, 
+                                 double cutoff_value, struct md_allocator_i* alloc);
+
+// Molecular orbital data
+
+// Get the number of molecular orbitals
+size_t md_trexio_mo_num(const struct md_trexio_t* trexio);
+
+// Get MO coefficients (array of size ao_num * mo_num)
+const double* md_trexio_mo_coefficient(const struct md_trexio_t* trexio);
+
+// Get MO energies in Hartree (array of size mo_num)
+const double* md_trexio_mo_energy(const struct md_trexio_t* trexio);
+
+// Get MO occupations (array of size mo_num)
+const double* md_trexio_mo_occupation(const struct md_trexio_t* trexio);
+
+// Get MO class (array of strings, size mo_num) - e.g., "Core", "Inactive", "Active", "Virtual"
+const char** md_trexio_mo_class(const struct md_trexio_t* trexio);
+
+// Get MO symmetry labels (array of strings, size mo_num)
+const char** md_trexio_mo_symmetry(const struct md_trexio_t* trexio);
+
+// Extract Molecular Orbital GTOs
+// mo_idx: Molecular Orbital Index
+// value_cutoff: A cutoff value to calculate effective radius (0 = no cutoff)
+// Returns the number of GTOs written
+size_t md_trexio_mo_gto_count(const md_trexio_t* trexio);
+size_t md_trexio_mo_gto_extract(md_gto_t gtos[], const md_trexio_t* trexio, 
+                                 size_t mo_idx, double value_cutoff);
+
+// Electron data
+
+// Get the number of up-spin electrons
+size_t md_trexio_num_up_electrons(const struct md_trexio_t* trexio);
+
+// Get the number of down-spin electrons
+size_t md_trexio_num_down_electrons(const struct md_trexio_t* trexio);
+
+// System loader interface
+
+// Initialize md_system_t from TREXIO data
+bool md_trexio_system_init(struct md_system_t* sys, const md_trexio_t* trexio, 
+                            struct md_allocator_i* alloc);
+
+// Get the system loader interface for TREXIO
+struct md_system_loader_i* md_trexio_system_loader(void);
+
+#ifdef __cplusplus
+}
+#endif
